'use strict';

/**
 * Created by PHE on 2016/7/7.
 */

let docClient;

module.exports = (aws => {
  if (!docClient && aws) {
    docClient = new aws.DynamoDB.DocumentClient();
  }

  // Convert DynamoDB error code into Error object
  const getDynamoDBError = err => {
    if (err.statusCode === 400) {
      switch (err.code) {
        case "AccessDeniedException":
        case "UnrecognizedClientException":
          return new Error("401 Unauthorized: Unable to access an item with error: " + JSON.stringify(err));
        default:
          return new Error("400 Bad Request: Unable to access an item with error: " + JSON.stringify(err));
      }
    } else { // 500, 503
      return new Error("500 Internal Server Error: Unable to access an item with error: " + JSON.stringify(err));
    }
  };

  /**
   * Parameters:
   * Key        Description
   * surveyid   an uuid is generated by backend and associate to a survey as it creates first time.
   * clientid   an unique identify for client app, or browser.
   *
   * Response:
   * Key        Description
   * surveyid   an uuid is generated by backend and associate to a survey as it creates first time.
   * clientid   an unique identify for client app, or browser.
   * feedback   The details of the feedback model in JSON format
   * datetime   The latest modified date time of the feedback.
   */
  const getOneFeedback = event => {
    let response = null;
    return new Promise((resolve, reject) => {
      // validate parameters
      if (event.surveyid && event.clientid && process.env.SERVERLESS_FEEDBACKTABLE) {
        let params = {
          TableName: process.env.SERVERLESS_FEEDBACKTABLE,
          Key: {
            surveyid: event.surveyid,
            clientid: event.clientid,
          },
        };

        docClient.get(params, (err, data) => {
          if (err) {
            console.error("Unable to get an item with the request: ", JSON.stringify(params), " along with error: ", JSON.stringify(err));
            reject(getDynamoDBError(err));
          } else {
            if (data.Item) { // got response
              // compose response
              response = {
                surveyid: data.Item.surveyid,
                clientid: data.Item.clientid,
                feedback: data.Item.feedback,
                datetime: data.Item.datetime,
              };
              resolve(response);
            } else {
              console.error("Unable to get an item with the request: ", JSON.stringify(params));
              reject(new Error("404 Not Found: Unable to get an item with the request: " + JSON.stringify(params)));
            }
          }
        });
      } else { // incomplete parameters
        reject(new Error("400 Bad Request: Missing parameters: " + JSON.stringify(event)));
      }
    });
  };

  /**
   * Parameters:
   * Key        Description
   * surveyid   an uuid is generated by backend and associate to a survey as it creates first time.
   * startKey   If your query amount to more than 1 MB of data, you'll need to perform another query request for the next 1 MB of data.
   *            To do this, take the lastEvaluatedKey value from the previous request, and use that value as the startKey in the next request.
   *            This approach will let you progressively query for new data in 1 MB increments.
   *
   * Response:
   * Key        Description
   * feedbacks  An array of feedbacks objects (see below)
   *
   * Each object in the feedback array contains:
   * surveyid   an uuid is generated by backend and associate to a survey as it creates first time.
   * clientid   an unique identify for client app, or browser.
   * datetime   The latest modified date time of the feedback.
   */
  const listFeedbacks = event => {
    let response = null;
    return new Promise((resolve, reject) => {
      // validate parameters
      if (event.surveyid && process.env.SERVERLESS_FEEDBACKTABLE) {
        let params = {
          TableName: process.env.SERVERLESS_FEEDBACKTABLE,
          ProjectionExpression: "surveyid, clientid, #dt",
          KeyConditionExpression: "surveyid = :surveyid",
          ExpressionAttributeNames: {
            "#dt": "datetime",
          },
          ExpressionAttributeValues: {
            ":surveyid": event.surveyid,
          },
        };

        // continue querying if we have more data
        if (event.startKey) {
          params.ExclusiveStartKey = event.startKey;
        }
        // turn on the limit in testing mode
        if (event.limitTesting) {
          params.Limit = 1;
        }

        docClient.query(params, (err, data) => {
          if (err) {
            console.error("Unable to get an item with the request: ", JSON.stringify(params), " along with error: ", JSON.stringify(err));
            reject(getDynamoDBError(err));
          } else {
            // got and compose response
            response = {
              feedbacks: data.Items,
            };

            // LastEvaluatedKey
            if (typeof data.LastEvaluatedKey !== "undefined") {
              response.LastEvaluatedKey = data.LastEvaluatedKey;
            }
            resolve(response);
          }
        });
      } else {
        reject(new Error("400 Bad Request: Missing parameters: " + JSON.stringify(event)));
      }
    });
  };

  /**
   * Parameters:
   * Key        Description
   * surveyid   an uuid is generated by backend and associate to a survey as it creates first time.
   *
   * Response:
   * Key        Description
   * ScannedCount — the number of items that were queried or scanned, before any filter expression was applied to the results.
   * Count — the number of items that were returned in the response.
   */
  const countFeedbacks = event => {
    let response = null;
    return new Promise((resolve, reject) => {
      // validate parameters
      if (event.surveyid && process.env.SERVERLESS_FEEDBACKTABLE) {
        let params = {
          TableName: process.env.SERVERLESS_FEEDBACKTABLE,
          KeyConditionExpression: "surveyid = :surveyid",
          ExpressionAttributeValues: {
            ":surveyid": event.surveyid,
          },
          Select: "COUNT",
        };

        docClient.query(params, (err, data) => {
          if (err) {
            console.error("Unable to get an item with the request: ", JSON.stringify(params), " along with error: ", JSON.stringify(err));
            reject(getDynamoDBError(err));
          } else {
            // got and compose response
            response = data;
            resolve(response);
          }
        });
      } else {
        reject(new Error("400 Bad Request: Missing parameters: " + JSON.stringify(event)));
      }
    });
  };

  /**
   * Parameters:
   * Key        Description
   * surveyid   an uuid is generated by backend and associate to a survey as it creates first time.
   * accountid  FB account id with prefix facebook, ex: facebook-10206181895733803
   *
   * Response:
   * accountid  FB account id with prefix facebook, ex: facebook-10206181895733803
   * surveyid   an uuid is generated by backend and associate to a survey as it creates first time.
   * subject    The subject of the survey
   * survey     The survey content.
   * data       Total feedback data in this survey.
   * datetime   The latest modified date time of the survey
   *
   */
  const reportFeedbacks = event => {
    return new Promise((resolve, reject) => {
      // validate parameters
      if (event.accountid && event.surveyid && process.env.SERVERLESS_FEEDBACKTABLE) {
        const survey = require('../survey/survey.js')(aws);
        let params = {
          TableName: process.env.SERVERLESS_FEEDBACKTABLE,
          ProjectionExpression: "surveyid, clientid, feedback, #dt",
          KeyConditionExpression: "surveyid = :surveyid",
          ExpressionAttributeNames: {
            "#dt": "datetime",
          },
          ExpressionAttributeValues: {
            ":surveyid": event.surveyid,
          },
        };

        if (event.unitTest) { // for unitTest setting
          params.Limit = 1;
        }

        const feedbackDataHandler = responseData => {
          return new Promise((resolve, reject) => {
            docClient.query(params, (err, data) => {
              if (err) {
                console.error("Unable to get an item with the request: ", JSON.stringify(params), " along with error: ", JSON.stringify(err));
                reject(getDynamoDBError(err));
              } else {
                // got and compose response
                if (data.Items.length > 0) {  // For Last EvalutedKey final will return { Items: [], Count: 0, ScannedCount: 0 }
                  for (let item in data.Items) {
                    if (data.Items.hasOwnProperty(item)) {
                      responseData.data.push(data.Items[item]);
                    }
                  }
                }
                // continue querying if we have more data : LastEvaluatedKey
                if (typeof data.LastEvaluatedKey !== "undefined") {
                  params.ExclusiveStartKey = data.LastEvaluatedKey;
                  resolve(feedbackDataHandler(responseData));
                } else {
                  resolve(responseData);
                }
              }
            });
          });
        };

        survey.getOneSurvey({
          accountid: event.accountid,
          surveyid: event.surveyid,
        }).then(responseData => {
          responseData.data = [];
          return feedbackDataHandler(responseData);
        }).then(response => {
          resolve(response);
        }).catch(err => {
          reject(err);
        });
      } else {
        reject(new Error("400 Bad Request: Missing parameters: " + JSON.stringify(event)));
      }
    });
  };

  /**
   * Parameters:
   * Key        Description
   * surveyid   an uuid is generated by backend and associate to a survey as it creates first time.
   * clientid   an unique identify for client app, or browser.
   * feedback   The details of the feedback model in JSON format
   *
   * Response:
   * Key        Description
   * datetime   The latest modified date time of the feedback.
   */
  const addOneFeedback = event => {
    let response = null;
    return new Promise((resolve, reject) => {
      // validate parameters
      if (event.surveyid && event.clientid && event.feedback && process.env.SERVERLESS_FEEDBACKTABLE) {
        let datetime = Date.now();
        let params = {
          TableName: process.env.SERVERLESS_FEEDBACKTABLE,
          Item: {
            surveyid: event.surveyid,
            clientid: event.clientid,
            datetime: datetime,
            feedback: event.feedback,
          },
        };
        docClient.put(params, err => {
          if (err) {
            console.error("Unable to add a new item with the request: ", JSON.stringify(params), " along with error: ", JSON.stringify(err));
            reject(getDynamoDBError(err));
          } else {
            // compose response
            response = {
              datetime: datetime,
            };
            resolve(response);
          }
        });
      } else { // incomplete parameters
        reject(new Error("400 Bad Request: Missing parameters: " + JSON.stringify(event)));
      }
    });
  };

  /**
   * Parameters:
   * Key        Description
   * surveyid   an uuid is generated by backend and associate to a survey as it creates first time.
   * clientid   an unique identify for client app, or browser.
   * feedback   The details of the feedback model in JSON format
   *
   * Response:
   * Key        Description
   * feedback   The details of the feedback model in JSON format
   */
  const updateOneFeedback = event => {
    let response = null;
    return new Promise((resolve, reject) => {
      // validate parameters
      if (event.surveyid  && event.clientid && event.feedback && process.env.SERVERLESS_FEEDBACKTABLE) {
        let datetime = Date.now();
        let params = {
          TableName: process.env.SERVERLESS_FEEDBACKTABLE,
          Key:{
            surveyid: event.surveyid,
            clientid: event.clientid,
          },
          UpdateExpression: "set feedback = :feedback, #dt=:datetime",
          ExpressionAttributeValues:{
            ":feedback": event.feedback,
            ":datetime": datetime,
          },
          ExpressionAttributeNames: {
            "#dt": "datetime",
          },
          "ConditionExpression": "(attribute_exists(surveyid)) AND (attribute_exists(clientid)) ",
          ReturnValues:"UPDATED_NEW",
        };
        docClient.update(params, (err, data) => {
          if (err) {
            if (err.code === "ConditionalCheckFailedException") {
              console.error("Unable to update an item with the request: ", JSON.stringify(params));
              reject(new Error("404 Not Found: Unable to update an not exist item with the request: " + JSON.stringify(params)), null);
            } else {
              console.error("Unable to update an item with the request: ", JSON.stringify(params), " along with error: ", JSON.stringify(err));
              reject(getDynamoDBError(err));
            }
          } else {
            // compose response
            response = {
              feedback: data.Attributes.feedback,
            };
            resolve(response);
          }
        });
      } else { // incomplete parameters
        reject(new Error("400 Bad Request: Missing parameters: " + JSON.stringify(event)));
      }
    });
  };

  /**
   * Parameters:
   * Key        Description
   * surveyid   an uuid is generated by backend and associate to a survey as it creates first time.
   * clientid   an unique identify for client app, or browser.
   *
   * Response:
   * None
   */
  const deleteFeedbacks = (event, otherParams) => {
    let params = {};
    return new Promise((resolve, reject) => {
      // validate parameters
      if (event.surveyid  && event.clientid && process.env.SERVERLESS_FEEDBACKTABLE) {
        params = {
          TableName: process.env.SERVERLESS_FEEDBACKTABLE,
          Key: {
            clientid: event.clientid,
            surveyid: event.surveyid,
          },
        };
        docClient.delete(params, err => {
          if (err) {
            console.error("Unable to delete an item with the request: ", JSON.stringify(params), " along with error: ", JSON.stringify(err));
            reject(getDynamoDBError(err));
          } else {
            resolve({}); // Response will be HTTP 200.
          }
        });
      } else if (event.surveyid && process.env.SERVERLESS_FEEDBACKTABLE) {
        params = {
          RequestItems: {
            [process.env.SERVERLESS_FEEDBACKTABLE]: [],
          },
        };
        listFeedbacks(event).then(response => {
          response.feedbacks.map(item => {
            params.RequestItems[process.env.SERVERLESS_FEEDBACKTABLE].push({
              DeleteRequest: {
                Key: {
                  clientid: item.clientid,
                  surveyid: item.surveyid,
                },
              }
            });
          });
          params = processBatchWrite(params, otherParams);
          if (Object.keys(params.RequestItems).length === 0) {
            // Dont need to access DDB without any request.
            resolve({}); // Response will be HTTP 200.
          }
          return params;
        }).then(excuteBatchWrite).then(() => {
          resolve({}); // Response will be HTTP 200.
        }).catch(err => {
          reject(err);
        });
      } else { // incomplete parameters
        reject(new Error("400 Bad Request: Missing parameters: " + JSON.stringify(event)));
      }
    });
  };

  /**
   * This function will combine two parameters in one for batchWrite()
   * but will not export out of this module
   * 1. Concat each request actions if they are for same table
   * 2. Extend the parameter object if other request actions is from different table
   * 3. Delete object key if its request actions is empty
   *
   * Response:
   * Valid parameter for batchWrite()
   */
  const processBatchWrite = (param1, param2) => {
    if (!param2) param2 = {RequestItems: {}};
    Object.keys(param2.RequestItems).forEach(key => {
      if (param1.RequestItems.hasOwnProperty(key) && Array.isArray(param1.RequestItems[key])) {
        param1.RequestItems[key] = param1.RequestItems[key].concat(param2.RequestItems[key]);
      } else {
        param1.RequestItems[key] = param2.RequestItems[key];
      }
    });
    Object.keys(param1.RequestItems).forEach(key => {
      if (Array.isArray(param1.RequestItems[key]) && param1.RequestItems[key].length === 0) {
        delete param1.RequestItems[key];
      }
    });
    return param1;
  };

  /**
   * This function will excute batchWrite() with 25 request actions limitation
   * So currently not yet support batchWrite() with transaction
   * This function will not export out of this module
   *
   * Response:
   * Promise object for all excutions
   */
  const excuteBatchWrite = params => {
    const objKeys = Object.keys(params.RequestItems),
          total = objKeys.map(key => { return params.RequestItems[key].length; }).reduce((a, b) => { return a + b; }, 0);
    let excuteArr = [],
        task = {RequestItems: {}},
        i = 0,
        tableIndex = 0,
        tableName = objKeys[tableIndex],
        itemIndex = 0;

    if (!task.RequestItems[tableName]) {
      task.RequestItems[tableName] = [];
    }

    while (i < total) {
      task.RequestItems[tableName].push(params.RequestItems[tableName][itemIndex]);

      if (itemIndex + 1 === params.RequestItems[tableName].length) {
        tableIndex += 1;
        itemIndex = 0;
        tableName = objKeys[tableIndex];
        if (tableName && !task.RequestItems[tableName]) {
          task.RequestItems[tableName] = [];
        }
      } else {
        itemIndex += 1;
      }

      if (i + 1 === 25 || i + 1 === total) {
        excuteArr.push(task);
        task = {RequestItems: {}};
        if (!task.RequestItems[tableName]) {
          task.RequestItems[tableName] = [];
        }
      }
      i += 1;
    }

    excuteArr = excuteArr.map(params => {
      return new Promise((resolve, reject) => {
        docClient.batchWrite(params, err => {
          if (err) {
            console.error("Unable to delete all item with the request: ", JSON.stringify(params), " along with error: ", JSON.stringify(err));
            reject(getDynamoDBError(err));
          } else {
            resolve({}); // Response will be HTTP 200.
          }
        });
      });
    });

    return Promise.all(excuteArr);
  };

  return {
    getOneFeedback,
    listFeedbacks,
    countFeedbacks,
    reportFeedbacks,
    addOneFeedback,
    updateOneFeedback,
    deleteFeedbacks,
  };
});